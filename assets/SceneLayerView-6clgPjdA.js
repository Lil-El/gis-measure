const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-DXZ_271k.js","assets/index-DbfyjNSR.css"])))=>i.map(i=>d[i]);
import{cU as K,az as $,ai as Q,e as c,y as p,a as O,a0 as D,kQ as W,kR as Y,m as H,a2 as J,kS as X,kT as Z,bW as ee,bV as te,C as re,a_ as T,dL as C,_ as ne,kU as R,bS as se,bT as ie,u as oe}from"./index-DXZ_271k.js";import{n as v}from"./HeatmapDensity.glsl-DAGCSh3F.js";import{a as le,n as ae,u as ue}from"./DefinitionExpressionSceneLayerView-BoynLq_X.js";import{d as de}from"./LayerView-D85gm5GC.js";const ce={setAttribute(){},setGeometry(e){},rollback(){},commit(){}};var E;function Ee(e,r){const t=r.attributes[e.objectIdField],n=e.sessions.get(t);if(n)return n;const s=K(r.attributes),o=new Set;if(t==null)return ce;const a=e.i3sOverrides.createInteractiveEditSession(t),i=new Map,y=(m,b)=>{const f=i.get(m);if(f==null){const u=b.indexOf(t);return i.set(m,u),u}return f};let l=E.EDITING;const g={setAttribute(m,b){if(l!==E.EDITING)return;const f=e.fieldsIndex.get(m);if(!f)return;const u=e.attributeStorageInfo.findIndex(F=>F.name===f.name);if(u<0)return;a.setAttribute(u,b);const d=e.attributeStorageInfo[u];let h=!1;o.add(m),e.forEachNode((F,_)=>{const A=y(F,_);if(A===-1)return;const N=e.getAttributeData(F.index);if(N){const U=N[d.name];U&&(U[A]=b,e.setAttributeData(F.index,N,r),h=!0)}}),h&&e.clearMemCache()},setGeometry(m){l===E.EDITING&&a.setGeometry(m)},rollback(){if(l===E.EDITING){for(const m of o)this.setAttribute(m,s[m]);a.rollback(),l=E.ROLLED_BACK,e.sessions.delete(t)}},commit(){l===E.EDITING&&(a.commit(),l=E.COMMITTED,e.sessions.delete(t))}};return e.sessions.set(t,g),g}function xe(e,r){var f;const t=e.fieldsIndex,n=e.objectIdField,s=e.globalIdField;if(s==null)return;const o=new Map,a=P(r.addedFeatures),i=r.edits.addFeatures,y=L(r.updatedFeatures),l=r.edits.updateFeatures,g=me(t,n,s,(f=r.edits)==null?void 0:f.deleteFeatures),m=L(r.deletedFeatures,g),b=r.edits.deleteFeatures;if(i!=null&&i.length>0)for(const u of i){const d=v(t,u.attributes,s),h=a.get(d);u.geometry!=null&&u.geometry.type==="mesh"&&h!=null&&o.set(h,u.geometry)}if(l!=null&&l.length>0)for(const u of l){const d=v(t,u.attributes,n);u.geometry!=null&&u.geometry.type==="mesh"&&y.has(d)&&o.set(d,u.geometry)}if(b!=null&&b.length>0)for(const u of b){let d=null;d="attributes"in u?v(t,u.attributes,n):u.objectId,d!=null&&m.has(d)&&o.set(d,null)}for(const[u,d]of o)e.i3sOverrides.updateGeometry(u,d)}function ve(e,r){var b;const t=pe(e,r),n=fe(e,r);if(t.size===0&&n.size===0)return;const s=new Map;for(let f=0;f<e.attributeStorageInfo.length;f++)s.set(e.attributeStorageInfo[f].name,f);let o=!1;t.forEach((f,u)=>{const d=e.getAttributeData(u);let h=!1;f.forEach((F,_)=>{const A=d!=null?d[_]:null,N=s.get(_);for(const{featureIndex:U,value:M,featureId:B}of F)A&&(A[U]=M,h=!0,o=!0),e.i3sOverrides.updateAttributeValue(B,N,M)}),h&&e.setAttributeData(u,d,null)}),o&&e.clearMemCache();const{fieldsIndex:a,i3sOverrides:i,objectIdField:y,globalIdField:l}=e,g=(b=i.layer.associatedLayer)==null?void 0:b.infoFor3D,m=new Set(g?[...Object.values(g.assetMapFieldRoles),...Object.values(g.transformFieldRoles)]:[]);for(const[f,u]of n){i.featureAdded(f);const{attributes:d}=u;for(const h in d){if(h!==y&&h!==l&&m.has(h))continue;const F=a.normalizeFieldName(h),_=F!=null?s.get(F):null;if(_==null)continue;const A=d[h];i.updateAttributeValue(f,_,A)}}}function fe(e,{edits:r,addedFeatures:t}){const n=new Map,s=r.addAssetFeatures,{fieldsIndex:o,globalIdField:a}=e;if(!s||s.length===0||a==null)return n;const i=P(t);for(const y of s){const l=v(o,y.attributes,a),g=i.get(l);y.geometry!=null&&y.geometry.type==="mesh"&&g!=null&&n.set(g,y)}return n}function pe(e,r){const t=r.edits.updateFeatures;if(!t||t.length===0)return new k;const n=L(r.updatedFeatures),s=new k,o=new Map;for(let l=0;l<e.attributeStorageInfo.length;l++)o.set(e.attributeStorageInfo[l].name,l);const a=e.fieldsIndex,i=e.objectIdField,y=t.filter(l=>{const g=v(a,l.attributes,i);return n.has(g)});return e.forEachNode((l,g)=>{const m=new Set(g);for(const b of y){const f=v(a,b.attributes,i);if(!m.has(f))continue;const u=g.indexOf(f);for(const d in b.attributes){const h=e.fieldsIndex.normalizeFieldName(d),F=ye(s,l.index,h),_=b.attributes[d];F.push({featureIndex:u,featureId:f,value:_})}}}),s}function ye(e,r,t){const n=ge(e,r),s=t!=null&&n.get(t);if(s)return s;const o=new Array;return n.set(t,o),o}function ge(e,r){const t=e.get(r);if(t)return t;const n=new he;return e.set(r,n),n}function me(e,r,t,n){const s=new Map;if(!n)return s;for(const o of n){let a=null,i=null;"attributes"in o?(a=v(e,o.attributes,r),i=v(e,o.attributes,t)):(a=o.objectId,i=o.globalId),i!=null&&a!=null&&s.set(i,a)}return s}function P(e){const r=new Map;if(!e)return r;for(const t of e)t.globalId!=null&&t.objectId!=null&&t.error==null&&r.set(t.globalId,t.objectId);return r}function L(e,r=null){const t=new Set;if(!e)return t;for(const n of e)if(n.error==null){if(n.objectId!=null&&n.objectId!==-1)t.add(n.objectId);else if(n.globalId!=null&&r!=null){const s=r.get(n.globalId);s!=null&&t.add(s)}}return t}(function(e){e[e.EDITING=0]="EDITING",e[e.ROLLED_BACK=1]="ROLLED_BACK",e[e.COMMITTED=2]="COMMITTED"})(E||(E={}));const he=Map,k=Map;function Ae(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:e,layer:{fieldsIndex:r},requiredFields:t}=this;return e.outFields?$(r,[...Q(r,e.outFields),...t]):$(r,t)}}}}const G=e=>{let r=class extends e{constructor(){super(...arguments),this._numUpdating=0,this._asyncUpdateState=new Map}get updating(){return this._numUpdating>0}autoUpdateAsync(t,n){return be(s=>this._updateAsync(t,s),n)}async _updateAsync(t,n){if(!this._startAsyncUpdate(t)){try{const s=await n();this._set(t,s)}catch{D.getLogger(this).warn(`Async update of "${String(t)}" failed. Async update functions should not throw exceptions.`)}this._endAsyncUpdate(t)&&this._updateAsync(t,n)}}_startAsyncUpdate(t){const n=this._asyncUpdateState.get(t)??w.None;return n&w.Updating?(this._asyncUpdateState.set(t,n|w.Invalidated),!0):(++this._numUpdating,this._asyncUpdateState.set(t,n|w.Updating),!1)}_endAsyncUpdate(t){--this._numUpdating;const n=(this._asyncUpdateState.get(t)??w.None)&~w.Updating;return n&w.Invalidated?(this._asyncUpdateState.set(t,n&~w.Invalidated),!0):(this._asyncUpdateState.set(t,n),!1)}};return c([p({readOnly:!0})],r.prototype,"updating",null),c([p()],r.prototype,"_numUpdating",void 0),r=c([O("esri.core.AsyncUpdate")],r),r};var w;function be(e,r){const t=()=>{o&&!a&&e(n)},n=()=>{if(!o||a)return r();o.clear(),a=!0;const i=Y(o,r);return a=!1,i},s=()=>{o&&(o.destroy(),o=null)};let o=new W(t),a=!1;return e(n),{remove:s}}(function(e){e[e.None=0]="None",e[e.Updating=1]="Updating",e[e.Invalidated=2]="Invalidated"})(w||(w={}));let q=class extends G(H){};q=c([O("esri.core.AsyncUpdate")],q);const V="esri.views.3d.layers.support.SceneLayerViewRequiredFields";let x=class extends G(J){get layer(){return this.layerView.layer}get requiredFields(){const{layerView:{layer:{fieldsIndex:e},definitionExpressionFields:r},rendererFields:t,labelingFields:n,viewFilterFields:s}=this;return $(e,[...r??[],...t??[],...n??[],...s??[]])}constructor(e){super(e)}initialize(){this.handles.add([this.autoUpdateAsync("rendererFields",async()=>{const{fieldsIndex:e,renderer:r}=this.layer;return r?j(t=>r.collectRequiredFields(t,e)):null}),this.autoUpdateAsync("labelingFields",async()=>{const{layer:e}=this;return e.labelsVisible?j(r=>X(r,e)):null}),this.autoUpdateAsync("viewFilterFields",()=>{const{layer:e,filter:r}=this.layerView;return j(t=>Z(t,e,r))})])}};async function j(e){const r=new Set;try{return await e(r),Array.from(r).sort()}catch(t){return D.getLogger(V).error(t),null}}c([p()],x.prototype,"layerView",void 0),c([p()],x.prototype,"layer",null),c([p()],x.prototype,"requiredFields",null),c([p()],x.prototype,"rendererFields",void 0),c([p()],x.prototype,"labelingFields",void 0),c([p()],x.prototype,"viewFilterFields",void 0),x=c([O(V)],x);const z="esri.views.layers.SceneLayerView",S=D.getLogger(z);let I=class extends de{constructor(){super(...arguments),this.layer=null,this.filter=null,this._geometryEngine=null,this._projectionEngineLoaded=!1,this._abortController=new AbortController}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}get layerFilter(){return le(this._layerFilter)}get _layerFilter(){const e=this.layer.filter;if(e==null||e.geometries.length<1)return null;const r=this._geometryEngine;if(r==null||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine)return ae;const t=e.geometries.at(0).spatialReference,n=e.geometries.toArray().map(i=>{try{i=r.simplify(i)}catch{return S.warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."),null}if(i==null)return null;if(i.spatialReference.equals(t))return i;try{return ee(i,t)}catch{return S.warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."),null}}).filter(te).sort((i,y)=>i.extent.xmin-y.extent.xmin),s=new Set,o=new Array,a=new Array;for(let i of n){const y=i.extent.xmin;if(o.length=0,s.forEach(l=>{if(y>=l.extent.xmax)return a.push(l),void s.delete(l);i.extent.ymin<=l.extent.ymax&&i.extent.ymax>=l.extent.ymin&&r.intersects(i,l)&&o.push(l)}),o.length>0){o.push(i);try{i=r.union(o)}catch{S.warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");continue}o.pop(),o.forEach(l=>s.delete(l))}s.add(i)}return s.forEach(i=>a.push(i)),a.length>0?{spatialRelationship:e.spatialRelationship,geometries:a}:null}get _filterNeedsProjectionEngine(){const e=this.layer.filter;if(e==null||e.geometries.length<=1)return!1;const r=e.geometries.at(0).spatialReference;return e.geometries.some(({spatialReference:t})=>!t.equals(r)&&!re(t,r))}get layerFilterUpdating(){return ue(this._layerFilter)}initialize(){const{signal:e}=this._abortController;T(()=>{var r,t,n;return this.destroyed||!this._geometryEngine&&((n=(t=(r=this.layer)==null?void 0:r.filter)==null?void 0:t.geometries)==null?void 0:n.length)},e).then(async()=>{C(e),this._geometryEngine=await ne(()=>import("./index-DXZ_271k.js").then(r=>r.ww),__vite__mapDeps([0,1]))}).catch(R),this._projectionEngineLoaded=se(),T(()=>this.destroyed||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine,e).then(async()=>{C(e),await ie(),this._projectionEngineLoaded=!0}).catch(R)}destroy(){this._abortController=oe(this._abortController)}highlight(e){throw new Error("Not implemented")}queryFeatures(e,r){throw new Error("Not implemented")}queryObjectIds(e,r){throw new Error("Not implemented")}queryFeatureCount(e,r){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,r){throw new Error("Not implemented")}};c([p()],I.prototype,"layer",void 0),c([p()],I.prototype,"availableFields",null),c([p()],I.prototype,"maximumNumberOfFeatures",null),c([p({readOnly:!0})],I.prototype,"maximumNumberOfFeaturesExceeded",null),c([p()],I.prototype,"filter",void 0),c([p({readOnly:!0})],I.prototype,"layerFilter",null),c([p({readOnly:!0})],I.prototype,"_layerFilter",null),c([p()],I.prototype,"_geometryEngine",void 0),c([p()],I.prototype,"_projectionEngineLoaded",void 0),c([p()],I.prototype,"_filterNeedsProjectionEngine",null),c([p()],I.prototype,"layerFilterUpdating",null),I=c([O(z)],I);const Ue=I;export{Ae as i,Ue as j,ve as l,x as p,Ee as r,xe as s};
