import{be as l,f6 as f,f8 as d}from"./index-Cy4mlNgs.js";function i(t){var r;return Array.isArray(t)?(r=t[0])==null?void 0:r.spatialReference:t==null?void 0:t.spatialReference}function w(t){return t&&(Array.isArray(t)?t.map(w):t.toJSON?t.toJSON():t)}function u(t){return Array.isArray(t)?t.map(r=>f(r)):f(t)}function m(t,r){let e;return Array.isArray(t)?e=t:(e=[],e.push(t),r!=null&&e.push(r)),e}let s;async function g(){return s||(s=d("geometryEngineWorker",{strategy:"distributed"})),s}async function n(t,r){return(await g()).invoke("executeGEOperation",{operation:t,parameters:w(r)})}async function h(t,r){return u(await n("clip",[i(t),t,r]))}async function O(t,r){return u(await n("cut",[i(t),t,r]))}function S(t,r){return n("contains",[i(t),t,r])}function J(t,r){return n("crosses",[i(t),t,r])}function N(t,r,e){return n("distance",[i(t),t,r,e])}function E(t,r){return n("equals",[i(t),t,r])}function R(t,r){return n("intersects",[i(t),t,r])}function b(t,r){return n("touches",[i(t),t,r])}function v(t,r){return n("within",[i(t),t,r])}function k(t,r){return n("disjoint",[i(t),t,r])}function D(t,r){return n("overlaps",[i(t),t,r])}function L(t,r,e){return n("relate",[i(t),t,r,e])}function j(t){return n("isSimple",[i(t),t])}async function B(t){return u(await n("simplify",[i(t),t]))}async function C(t,r=!1){return u(await n("convexHull",[i(t),t,r]))}async function G(t,r){return u(await n("difference",[i(t),t,r]))}async function H(t,r){return u(await n("symmetricDifference",[i(t),t,r]))}async function V(t,r){return u(await n("intersect",[i(t),t,r]))}async function W(t,r=null){const e=m(t,r);return u(await n("union",[i(e),e]))}async function $(t,r,e,a,c,o){return u(await n("offset",[i(t),t,r,e,a,c,o]))}async function q(t,r,e,a=!1){const c=[i(t),t,r,e,a];return u(await n("buffer",c))}async function z(t,r,e,a,c,o){const p=[i(t),t,r,e,a,c,o];return u(await n("geodesicBuffer",p))}async function F(t,r,e=!0){const a=await n("nearestCoordinate",[i(t),t,r,e]);return{...a,coordinate:l.fromJSON(a.coordinate)}}async function I(t,r){const e=await n("nearestVertex",[i(t),t,r]);return{...e,coordinate:l.fromJSON(e.coordinate)}}function A(t){var r;return"xmin"in t?t.center:"x"in t?t:(r=t.extent)==null?void 0:r.center}async function K(t,r,e){if(t==null)throw new y;const a=t.spatialReference;if((e=e??A(t))==null)throw new y;const c=t.constructor.fromJSON(await n("rotate",[a,t,r,e]));return c.spatialReference=a,c}async function M(t,r,e,a){return u(await n("generalize",[i(t),t,r,e,a]))}async function P(t,r,e){return u(await n("densify",[i(t),t,r,e]))}async function T(t,r,e,a=0){return u(await n("geodesicDensify",[i(t),t,r,e,a]))}function U(t,r){return n("planarArea",[i(t),t,r])}function Z(t,r){return n("planarLength",[i(t),t,r])}function Q(t,r,e){return n("geodesicArea",[i(t),t,r,e])}function X(t,r,e){return n("geodesicLength",[i(t),t,r,e])}class y extends Error{constructor(){super("Illegal Argument Exception")}}export{k as A,M as B,P as C,V as D,G as E,Z as F,K as H,j as J,Q as K,q as L,X as M,B as N,D as O,z as P,L as R,b as S,F as T,T as U,I as V,U as W,W as b,N as d,E as g,R as h,C as j,H as k,J as m,S as p,$ as v,O as w,v as x,h as y};
