import{b as I,dj as v,dk as S,di as M,dh as w,dn as b,dp as R,dq as Q,dr as Z,bM as D}from"./index-DXZ_271k.js";import{t as k,n as A}from"./objectIdUtils-4dd1rf9p.js";import{m as C}from"./FeatureStore-D3QnQQoO.js";import{e as P,f as _,g as E}from"./QueryEngine-BrcpEFqq.js";import{i as G,a as $,o as z}from"./clientSideDefaults-Ds-HLSRv.js";import{y as B,u as g,d as x,c as T,h as q}from"./sourceUtils-DgATg7w0.js";import"./BoundsStore-dpF2-ksy.js";import"./PooledRBush-BPeon5hL.js";import"./quickselect-6rhOiUTK.js";import"./optimizedFeatureQueryEngineAdapter-Cw430D86.js";import"./centroid-BDoZr6aR.js";import"./normalizeUtils-CDS1zMoz.js";import"./normalizeUtilsCommon-2BmMsmbE.js";import"./WhereClause-DBaFEMxw.js";import"./executionError-N6aCOFps.js";import"./json-Wa8cmqdu.js";import"./QueryEngineCapabilities-Dk3NJwmm.js";import"./utils-Cm2_MhmP.js";import"./generateRendererUtils-Cc7cXku3.js";const L=w,W={xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:w},U={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};function H(m){return D(m)?m.z!=null:!!m.hasZ}function V(m){return D(m)?m.m!=null:!!m.hasM}class ye{constructor(){this._queryEngine=null,this._nextObjectId=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(e){const t=[],{features:a}=e,i=this._inferLayerProperties(a,e.fields),o=e.fields||[],p=e.hasM!=null?e.hasM:!!i.hasM,c=e.hasZ!=null?e.hasZ:!!i.hasZ,f=!e.spatialReference&&!i.spatialReference,d=f?L:e.spatialReference||i.spatialReference,y=f?W:null,n=e.geometryType||i.geometryType,l=!n;let u=e.objectIdField||i.objectIdField,s=e.timeInfo;if(!l&&(f&&t.push({name:"feature-layer:spatial-reference-not-found",message:"Spatial reference not provided or found in features. Defaults to WGS84"}),!n))throw new I("feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if(!u)throw new I("feature-layer:missing-property","objectIdField not set and couldn't be found in the provided fields");if(i.objectIdField&&u!==i.objectIdField&&(t.push({name:"feature-layer:duplicated-oid-field",message:`Provided objectIdField "${u}" doesn't match the field name "${i.objectIdField}", found in the provided fields`}),u=i.objectIdField),u&&!i.objectIdField){let r=null;o.some(h=>h.name===u&&(r=h,!0))?(r.type="esriFieldTypeOID",r.editable=!1,r.nullable=!1):o.unshift({alias:u,name:u,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const r of o){if(r.name==null&&(r.name=r.alias),r.alias==null&&(r.alias=r.name),!r.name)throw new I("feature-layer:invalid-field-name","field name is missing",{field:r});if(r.name===u&&(r.type="esriFieldTypeOID"),!v.jsonValues.includes(r.type))throw new I("feature-layer:invalid-field-type",`invalid type for field "${r.name}"`,{field:r})}const F={};for(const r of o)if(r.type!=="esriFieldTypeOID"&&r.type!=="esriFieldTypeGlobalID"){const h=S(r);h!==void 0&&(F[r.name]=h)}if(this._fieldsIndex=new M(o),this._createDefaultAttributes=G(F,u),s){if(s.startTimeField){const r=this._fieldsIndex.get(s.startTimeField);r?(s.startTimeField=r.name,r.type="esriFieldTypeDate"):s.startTimeField=null}if(s.endTimeField){const r=this._fieldsIndex.get(s.endTimeField);r?(s.endTimeField=r.name,r.type="esriFieldTypeDate"):s.endTimeField=null}if(s.trackIdField){const r=this._fieldsIndex.get(s.trackIdField);r?s.trackIdField=r.name:(s.trackIdField=null,t.push({name:"feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:s}}))}s.startTimeField||s.endTimeField||(t.push({name:"feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing or invalid",details:{timeInfo:s}}),s=null)}const j={warnings:t,featureErrors:[],layerDefinition:{...U,drawingInfo:z(n),templates:$(F),extent:y,geometryType:n,objectIdField:u,fields:o,hasZ:c,hasM:p,timeInfo:s},assignedObjectIds:{}};if(this._queryEngine=new P({fields:o,geometryType:n,hasM:p,hasZ:c,objectIdField:u,spatialReference:d,featureStore:new C({geometryType:n,hasM:p,hasZ:c}),timeInfo:s,cacheSpatialQueries:!0}),!a||!a.length)return this._nextObjectId=k,j;const O=A(u,a);return this._nextObjectId=O+1,await _(a,d),this._loadInitialFeatures(j,a)}async applyEdits(e){const{spatialReference:t,geometryType:a}=this._queryEngine;return await Promise.all([B(t,a),_(e.adds,t),_(e.updates,t)]),this._applyEdits(e)}queryFeatures(e,t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e,t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e,t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e,t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_inferLayerProperties(e,t){let a,i,o=null,p=null,c=null;for(const f of e){const d=f.geometry;if(d!=null&&(o||(o=b(d)),p||(p=d.spatialReference),a==null&&(a=H(d)),i==null&&(i=V(d)),o&&p&&a!=null&&i!=null))break}if(t&&t.length){let f=null;t.some(d=>{const y=d.type==="esriFieldTypeOID",n=!d.type&&d.name&&d.name.toLowerCase()==="objectid";return f=d,y||n})&&(c=f.name)}return{geometryType:o,spatialReference:p,objectIdField:c,hasM:i,hasZ:a}}async _loadInitialFeatures(e,t){const{geometryType:a,hasM:i,hasZ:o,objectIdField:p,spatialReference:c,featureStore:f}=this._queryEngine,d=[];for(const l of t){if(l.uid!=null&&(e.assignedObjectIds[l.uid]=-1),l.geometry&&a!==b(l.geometry)){e.featureErrors.push(g("Incorrect geometry type."));continue}const u=this._createDefaultAttributes(),s=x(this._fieldsIndex,u,l.attributes,!0,e.warnings);s?e.featureErrors.push(s):(this._assignObjectId(u,l.attributes,!0),l.attributes=u,l.uid!=null&&(e.assignedObjectIds[l.uid]=l.attributes[p]),l.geometry!=null&&(l.geometry=E(l.geometry,l.geometry.spatialReference,c)),d.push(l))}f.addMany(R([],d,a,o,i,p));const{fullExtent:y,timeExtent:n}=await this._queryEngine.fetchRecomputedExtents();if(e.layerDefinition.extent=y,n){const{start:l,end:u}=n;e.layerDefinition.timeInfo.timeExtent=[l,u]}return e}async _applyEdits(e){const{adds:t,updates:a,deletes:i}=e,o={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(o,t),a&&a.length&&this._applyUpdateEdits(o,a),i&&i.length){for(const f of i)o.deleteResults.push(T(f));this._queryEngine.featureStore.removeManyById(i)}const{fullExtent:p,timeExtent:c}=await this._queryEngine.fetchRecomputedExtents();return{extent:p,timeExtent:c,featureEditResults:o}}_applyAddEdits(e,t){const{addResults:a}=e,{geometryType:i,hasM:o,hasZ:p,objectIdField:c,spatialReference:f,featureStore:d}=this._queryEngine,y=[];for(const n of t){if(n.geometry&&i!==b(n.geometry)){a.push(g("Incorrect geometry type."));continue}const l=this._createDefaultAttributes(),u=x(this._fieldsIndex,l,n.attributes);if(u)a.push(u);else{if(this._assignObjectId(l,n.attributes),n.attributes=l,n.uid!=null){const s=n.attributes[c];e.uidToObjectId[n.uid]=s}if(n.geometry!=null){const s=n.geometry.spatialReference??f;n.geometry=E(q(n.geometry,s),s,f)}y.push(n),a.push(T(n.attributes[c]))}}d.addMany(R([],y,i,p,o,c))}_applyUpdateEdits({updateResults:e},t){const{geometryType:a,hasM:i,hasZ:o,objectIdField:p,spatialReference:c,featureStore:f}=this._queryEngine;for(const d of t){const{attributes:y,geometry:n}=d,l=y&&y[p];if(l==null){e.push(g(`Identifier field ${p} missing`));continue}if(!f.has(l)){e.push(g(`Feature with object id ${l} missing`));continue}const u=Q(f.getFeature(l),a,o,i);if(n!=null){if(a!==b(n)){e.push(g("Incorrect geometry type."));continue}const s=n.spatialReference??c;u.geometry=E(q(n,s),s,c)}if(y){const s=x(this._fieldsIndex,u.attributes,y);if(s){e.push(s);continue}}f.add(Z(u,a,o,i,p)),e.push(T(l))}}_assignObjectId(e,t,a=!1){const i=this._queryEngine.objectIdField;a&&t&&isFinite(t[i])?e[i]=t[i]:e[i]=this._nextObjectId++}}export{ye as default};
