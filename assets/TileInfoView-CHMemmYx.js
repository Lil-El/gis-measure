import{aW as Y,bK as P,l2 as z}from"./index-ZXy_8vtR.js";var R,v,y,B,N,p,x;(function(o){o[o.FILL=0]="FILL",o[o.LINE=1]="LINE",o[o.MARKER=2]="MARKER",o[o.TEXT=3]="TEXT",o[o.LABEL=4]="LABEL"})(R||(R={})),function(o){o[o.NONE=0]="NONE",o[o.MAP=1]="MAP",o[o.LABEL=2]="LABEL",o[o.LABEL_ALPHA=4]="LABEL_ALPHA",o[o.HITTEST=8]="HITTEST",o[o.HIGHLIGHT=16]="HIGHLIGHT",o[o.CLIP=32]="CLIP",o[o.DEBUG=64]="DEBUG",o[o.NUM_DRAW_PHASES=9]="NUM_DRAW_PHASES"}(v||(v={})),function(o){o[o.SIZE=0]="SIZE",o[o.COLOR=1]="COLOR",o[o.OPACITY=2]="OPACITY",o[o.ROTATION=3]="ROTATION"}(y||(y={})),function(o){o[o.NONE=0]="NONE",o[o.OPACITY=1]="OPACITY",o[o.COLOR=2]="COLOR",o[o.ROTATION=4]="ROTATION",o[o.SIZE_MINMAX_VALUE=8]="SIZE_MINMAX_VALUE",o[o.SIZE_SCALE_STOPS=16]="SIZE_SCALE_STOPS",o[o.SIZE_FIELD_STOPS=32]="SIZE_FIELD_STOPS",o[o.SIZE_UNIT_VALUE=64]="SIZE_UNIT_VALUE"}(B||(B={})),function(o){o[o.MINMAX_TARGETS_OUTLINE=128]="MINMAX_TARGETS_OUTLINE",o[o.SCALE_TARGETS_OUTLINE=256]="SCALE_TARGETS_OUTLINE",o[o.FIELD_TARGETS_OUTLINE=512]="FIELD_TARGETS_OUTLINE",o[o.UNIT_TARGETS_OUTLINE=1024]="UNIT_TARGETS_OUTLINE"}(N||(N={})),function(o){o[o.SPRITE=0]="SPRITE",o[o.GLYPH=1]="GLYPH"}(p||(p={})),function(o){o[o.DEFAULT=0]="DEFAULT",o[o.SIMPLE=1]="SIMPLE",o[o.DOT_DENSITY=2]="DOT_DENSITY",o[o.OUTLINE_FILL=3]="OUTLINE_FILL",o[o.OUTLINE_FILL_SIMPLE=4]="OUTLINE_FILL_SIMPLE",o[o.HEATMAP=5]="HEATMAP",o[o.PIE_CHART=6]="PIE_CHART"}(x||(x={}));class C{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,l){const{spans:e,lodInfo:s}=this,{level:i}=s;if(e.length!==0)for(const{row:h,colFrom:r,colTo:n}of e)for(let a=r;a<=n;a++)t.call(l,i,h,s.normalizeCol(a),s.getWorldForColumn(a))}}C.pool=new Y(C);function M(o,t){return[o,t]}function w(o,t,l){return o[0]=t,o[1]=l,o}function D(o,t,l,e,s){return o[0]=t,o[1]=l,o[2]=e,o[3]=s,o}const d=new z("0/0/0/0");let H=class U{static create(t,l,e=null){const s=P(t.spatialReference),i=l.origin||M(t.origin.x,t.origin.y),h=M(t.size[0]*l.resolution,t.size[1]*l.resolution),r=M(-1/0,-1/0),n=M(1/0,1/0),a=M(1/0,1/0);e!=null&&(w(r,Math.max(0,Math.floor((e.xmin-i[0])/h[0])),Math.max(0,Math.floor((i[1]-e.ymax)/h[1]))),w(n,Math.max(0,Math.floor((e.xmax-i[0])/h[0])),Math.max(0,Math.floor((i[1]-e.ymin)/h[1]))),w(a,n[0]-r[0]+1,n[1]-r[1]+1));const{cols:c,rows:T}=l;let m,A,S,I;return!e&&c&&T&&(w(r,c[0],T[0]),w(n,c[1],T[1]),w(a,c[1]-c[0]+1,T[1]-T[0]+1)),t.isWrappable?(m=M(Math.ceil(Math.round((s.valid[1]-s.valid[0])/l.resolution)/t.size[0]),a[1]),A=M(Math.floor((s.origin[0]-i[0])/h[0]),r[1]),S=M(m[0]+A[0]-1,n[1]),I=!0):(A=r,S=n,m=a,I=!1),new U(l.level,l.resolution,l.scale,i,r,n,a,h,A,S,m,I)}constructor(t,l,e,s,i,h,r,n,a,c,T,m){this.level=t,this.resolution=l,this.scale=e,this.origin=s,this.first=i,this.last=h,this.size=r,this.norm=n,this.worldStart=a,this.worldEnd=c,this.worldSize=T,this.wrap=m}normalizeCol(t){if(!this.wrap)return t;const l=this.worldSize[0];return t<0?l-1-Math.abs((t+1)%l):t%l}denormalizeCol(t,l){return this.wrap?this.worldSize[0]*l+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,l,e=!1){d.set(l);const s=e?d.col:this.denormalizeCol(d.col,d.world),i=d.row;return D(t,this.getXForColumn(s),this.getYForRow(i+1),this.getXForColumn(s+1),this.getYForRow(i)),t}getTileCoords(t,l,e=!1){d.set(l);const s=e?d.col:this.denormalizeCol(d.col,d.world);return Array.isArray(t)?w(t,this.getXForColumn(s),this.getYForRow(d.row)):(t.x=this.getXForColumn(s),t.y=this.getYForRow(d.row)),t}};class F{constructor(t,l,e){this.row=t,this.colFrom=l,this.colTo=e}}const u=new z("0/0/0/0");class O{static create(t,l){t[1]>l[1]&&([t,l]=[l,t]);const[e,s]=t,[i,h]=l,r=i-e,n=h-s,a=n!==0?r/n:0,c=(Math.ceil(s)-s)*a,T=(Math.floor(s)-s)*a;return new O(e,Math.floor(s),Math.ceil(h),a,r<0?c:T,r<0?T:c,r<0?i:e,r<0?e:i)}constructor(t,l,e,s,i,h,r,n){this.x=t,this.ymin=l,this.ymax=e,this.invM=s,this.leftAdjust=i,this.rightAdjust=h,this.leftBound=r,this.rightBound=n}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const _=[[0,0],[0,0],[0,0],[0,0]],X=1e-6;class E{constructor(t,l=null,e=t.lods[0].level,s=t.lods[t.lods.length-1].level){this.tileInfo=t,this.fullExtent=l,this.scales=[],this._infoByScale={},this._infoByLevel={};const i=t.lods.filter(r=>r.level>=e&&r.level<=s);this.minScale=i[0].scale,this.maxScale=i[i.length-1].scale;const h=this._lodInfos=i.map(r=>H.create(t,r,l));i.forEach((r,n)=>{this._infoByLevel[r.level]=h[n],this._infoByScale[r.scale]=h[n],this.scales[n]=r.scale},this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel[typeof t=="number"?t:t.level]}getTileBounds(t,l,e=!1){u.set(l);const s=this._infoByLevel[u.level];return s?s.getTileBounds(t,u,e):t}getTileCoords(t,l,e=!1){u.set(l);const s=this._infoByLevel[u.level];return s?s.getTileCoords(t,u,e):t}getTileCoverage(t,l=192,e=!0,s="closest"){if(!e&&(t.scale>this.minScale||t.scale<this.maxScale))return null;const i=s==="closest"?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),h=C.pool.acquire(i),r=this._wrap;let n,a,c,T=1/0,m=-1/0;const A=h.spans;_[0][0]=_[0][1]=_[1][1]=_[3][0]=-l,_[1][0]=_[2][0]=t.size[0]+l,_[2][1]=_[3][1]=t.size[1]+l;for(const f of _)t.toMap(f,f),f[0]=i.getColumnForX(f[0]),f[1]=i.getRowForY(f[1]);const S=[];let I=3;for(let f=0;f<4;f++){if(_[f][1]===_[I][1]){I=f;continue}const L=O.create(_[f],_[I]);T=Math.min(L.ymin,T),m=Math.max(L.ymax,m),S[L.ymin]===void 0&&(S[L.ymin]=[]),S[L.ymin].push(L),I=f}if(T==null||m==null||m-T>100)return null;let g=[];for(n=T;n<m;){S[n]!=null&&(g=g.concat(S[n])),a=1/0,c=-1/0;for(let f=g.length-1;f>=0;f--){const L=g[f];a=Math.min(a,L.getLeftCol()),c=Math.max(c,L.getRightCol())}if(a=Math.floor(a),c=Math.floor(c),n>=i.first[1]&&n<=i.last[1])if(r)if(i.size[0]<i.worldSize[0]){const f=Math.floor(c/i.worldSize[0]);for(let L=Math.floor(a/i.worldSize[0]);L<=f;L++)A.push(new F(n,Math.max(i.getFirstColumnForWorld(L),a),Math.min(i.getLastColumnForWorld(L),c)))}else A.push(new F(n,a,c));else a>i.last[0]||c<i.first[0]||(a=Math.max(a,i.first[0]),c=Math.min(c,i.last[0]),A.push(new F(n,a,c)));n+=1;for(let f=g.length-1;f>=0;f--){const L=g[f];L.ymax>=n?L.incrRow():g.splice(f,1)}}return h}getTileParentId(t){u.set(t);const l=this._infoByLevel[u.level],e=this._lodInfos.indexOf(l)-1;return e<0?null:(this._getTileIdAtLOD(u,this._lodInfos[e],u),u.id)}getTileResolution(t){const l=this._infoByLevel[typeof t=="object"?t.level:t];return l?l.resolution:-1}getTileScale(t){const l=this._infoByLevel[t.level];return l?l.scale:-1}intersects(t,l){u.set(l);const e=this._infoByLevel[u.level],s=t.lodInfo;if(s.resolution>e.resolution){this._getTileIdAtLOD(u,s,u);const h=s.denormalizeCol(u.col,u.world);for(const r of t.spans)if(r.row===u.row&&r.colFrom<=h&&r.colTo>=h)return!0}if(s.resolution<e.resolution){const[h,r,n,a]=t.spans.reduce((I,g)=>(I[0]=Math.min(I[0],g.row),I[1]=Math.max(I[1],g.row),I[2]=Math.min(I[2],g.colFrom),I[3]=Math.max(I[3],g.colTo),I),[1/0,-1/0,1/0,-1/0]),c=e.denormalizeCol(u.col,u.world),T=s.getColumnForX(e.getXForColumn(c)),m=s.getRowForY(e.getYForRow(u.row)),A=s.getColumnForX(e.getXForColumn(c+1))-1,S=s.getRowForY(e.getYForRow(u.row+1))-1;return!(T>a||A<n||m>r||S<h)}const i=s.denormalizeCol(u.col,u.world);return t.spans.some(h=>h.row===u.row&&h.colFrom<=i&&h.colTo>=i)}normalizeBounds(t,l,e){if(t[0]=l[0],t[1]=l[1],t[2]=l[2],t[3]=l[3],this._wrap){const s=P(this.tileInfo.spatialReference),i=-e*(s.valid[1]-s.valid[0]);t[0]+=i,t[2]+=i}return t}getSmallestInfoForScale(t){const l=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>l[0])return this._infoByScale[l[0]];for(let e=1;e<l.length-1;e++)if(t>l[e]+X)return this._infoByScale[l[e-1]];return this._infoByScale[l[l.length-1]]}getClosestInfoForScale(t){const l=this.scales;return this._infoByScale[t]||(t=l.reduce((e,s)=>Math.abs(s-t)<Math.abs(e-t)?s:e,l[0])),this._infoByScale[t]}scaleToLevel(t){const l=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let e=l.length-1;e>=0;e--)if(t<l[e])return e===l.length-1?this._infoByScale[l[l.length-1]].level:this._infoByScale[l[e]].level+(l[e]-t)/(l[e]-l[e+1]);return this._infoByScale[l[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,l,e){const s=this._infoByLevel[e.level];return t.set(e),l.resolution<s.resolution?null:(l.resolution===s.resolution||(t.level=l.level,t.col=Math.floor(e.col*s.resolution/l.resolution+.01),t.row=Math.floor(e.row*s.resolution/l.resolution+.01)),t)}}export{N as A,R as E,B as L,x as S,v as T,E as h,C as l};
